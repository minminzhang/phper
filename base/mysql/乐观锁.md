#### 乐观锁
MySQL乐观锁是相对悲观锁而言的，乐观锁假设认为数据一般情况下不会发生冲突，所以在数据进行变更的时候才会正式对数据的冲突与否进行验证。
如果发生冲突了，则返回用户错误信息，让用户决定如何处理。

###### 如何实现乐观锁？
1，使用数据版本（Version）记录机制实现。这是乐观锁最常用的一种实现方式
```
数据版本：即为数据增加一个版本标识，一般是通过对数据表增加一个数字类型的“version”字段来实现，
当读取数据时，将version字段的值一同读出，数据每更新一次，对此version值加一。
当我们提交更新的时候，判断数据库表对应记录 的当前版本信息与第一次取出来的version值进行比对，
如果数据库表当前版本号与第一次取出来的version值相等，则予以更新，否则认为是过期数 据。

如果更新操作顺序执行，则数据的版本（version）依次递增，不会产生冲突。但是如果发生有不同的业务操作对同一版本的数据进行修 改，
那么，先提交的操作（图中B）会把数据version更新为2，当A在B之后提交更新时发现数据的version已经被修改了，那么A的更新操作会失败。
```
2，在需要乐观锁控制的table中增加一个字段，名称无所谓，字段类型使用时间戳 （timestamp）, 和上面的version类似，
也是在更新提交的时候检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，如果一致则OK，否则就是版本冲突。


乐观锁是基于程序实现的，所以不存在死锁的情况，适用于读多的应用场景。
如果经常发生冲突，上层应用不断的让用户进行重新操作，这反而降低了性能，这种情况下悲观锁就比较适用。

#### 悲观锁
顾名思义，就是对于数据的处理持悲观态度，总认为会发生并发冲突，获取和修改数据时，别人会修改数据。所以在整个数据处理过程中，需要将数据锁定。
悲观锁的实现，通常依靠数据库提供的锁机制实现，比如mysql的排他锁，select .... for update来实现悲观锁。

悲观锁在并发控制上采取的是先上锁然后再处理数据的保守策略，虽然保证了数据处理的安全性，但也降低了效率。
