## 数据库优化

#### 1，选择最适用的字段属性
MySQL可以很好的支持大数据量的存取，但是一般来说，数据库中的表越小，在它上面执行的查询也就越快。
因此，在创建表的时候，为了获得更好的性能，我们可以将表中字段的宽度设置的尽可能小。

比如：在定义邮政编码字段时，如果将其设置为CHAR(255)，显然给数据库增加了不必要的空间，甚至使用VARCHAR这种类型也是多余的，
因为CHAR(6)就可以很好的完成任务了。同样的，如果可以的话，我们应该使用mediumint而不是bigint来定义整型字段。

另外一个提高效率的方法是在可能的情况下，应该尽量把字段设置成 NOT NULL ，这样再将来执行查询的时候数据库不用去比较 NULL 值。
对于某些文本字段，例如“省份”或者“性别”，我们可以将他们定义成 enum 类型。因为在MySQL中，enum类型被当做数值类型来处理，
而数值型数据处理起来的速度比文本类型快得多。这样我们又可以提高数据库的性能。
#### 2，使用连接（join）来代替子查询
使用子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。
但是在有些情况下，子查询可以被更有效率的JOIN 连接替代。例如：假设我们需要把所有没有订单记录的用户取出来，
```
select * from customerinfo where customerid not in ( select customerid from salesinfo )
```
如果使用连接来完成这个查询工作，速度将会快很多。尤其是当 salesinfo 表中对 customerid 建立索引的话，性能将会更好，查询如下：
```
select * from customerinfo 
left join salesinfo where customerinfo.customerid = salesinfo.customerid 
where salesinfo.customer.id is null
```
连接（JOIN）之所以效率高，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。
###### 3，使用联合（union）来代替手动创建的临时表
MySQL从4.0版本开始支持union查询，它可以把需要使用临时表的条件或更多的select查询合并成一个。
在客户端会话结束的时候，临时表会被自动删除，从而保证数据库整齐、高效。
使用union来创建查询的时候，我们只需要用UNION作为关键字把多个select语句连接起来就可以了，要注意的是所有select语句中的字段数目要想同
###### 4，事务
尽管我们可以使用子查询（Sub-Queries）、连接（JOIN）和联合（UNION）来创建各种各样的查询，
但不是所有的数据库操作都可以只用一条或少数几条SQL语句就可以完成的。
更多的时候是需要用到一系列的语句来完成某种工作。但是在这种情况下，当这个语句块中的某一条语句运行出错的时候，
整个语句块的操作就会变得不确定起来。设想一下，要把某个数据同时插入两个相关联的表中，可能会出现这样的情况：
第一个表中成功更新后，数据库突然出现意外状况，造成第二个表中的操作没有完成，这样，就会造成数据的不完整，甚至会破坏数据库中的数据。
要避免这种情况，就应该使用事务，它的作用是：要么语句块中每条语句都操作成功，要么都失败。
换句话说，就是可以保持数据库中数据的一致性和完整性。事物以BEGIN关键字开始，COMMIT关键字结束。
在这之间的一条SQL操作失败，那么，ROLLBACK命令就可以把数据库恢复到BEGIN开始之前的状态。
```
BEGIN;
INSERT INTO salesinfo SET CustomerID=14;
UPDATE inventory SET Quantity=11 WHERE item='book';
COMMIT;
```
###### 5，锁定表
尽管事务是维护数据库完整性的一个非常好的方法，但却因为它的独占性，有时会影响数据库的性能，尤其是在很大的应用系统中。
由于在事务执行的过程中，数据库将会被锁定，因此其它的用户请求只能暂时等待直到该事务结束。如果一个数据库系统只有少数几个用户来使用，
事务造成的影响不会成为一个太大的问题；但假设有成千上万的用户同时访问一个数据库系统，例如访问一个电子商务网站，就会产生比较严重的响应延迟。

其实，有些情况下我们可以通过锁定表的方法来获得更好的性能。下面的例子就用锁定表的方法来完成前面一个例子中事务的功能。
```
LOCK TABLE inventory WRITE SELECT Quantity FROM inventory WHERE Item='book';
...
UPDATE inventory SET Quantity=11 WHERE Item='book'; UNLOCKTABLES
```
这里，我们用一个select语句取出初始数据，通过一些计算，用update语句将新值更新到表中。
包含有WRITE关键字的LOCKTABLE语句可以保证在UNLOCKTABLES命令被执行之前，不会有其它的访问来对inventory进行插入、更新或者删除的操作。
###### 6，使用外键
索引是提高数据库性能的常用方法，它可以令数据库服务器以比没有索引快得多的速度检索特定的行，
尤其是在查询语句当中包含有MAX(),MIN()和ORDERBY这些命令的时候，性能提高更为明显。

那该对哪些字段建立索引呢？

一般说来，索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上。尽量不要对数据库中某个含有大量重复的值的字段建立索引。
对于一个ENUM类型的字段来说，出现大量重复值是很有可能的情况

例如customerinfo中的“province”..字段，在这样的字段上建立索引将不会有什么帮助；相反，还有可能降低数据库的性能。
我们在创建表的时候可以同时创建合适的索引，也可以使用ALTERTABLE或CREATEINDEX在以后创建索引。此外，MySQL从版本3.23.23开始支持全文索引和搜索。
全文索引在MySQL中是一个FULLTEXT类型索引，但仅能用于MyISAM类型的表。对于一个大的数据库，将数据装载到一个没有FULLTEXT索引的表中，
然后再使用ALTERTABLE或CREATEINDEX创建索引，将是非常快的。但如果将数据装载到一个已经有FULLTEXT索引的表中，执行过程将会非常慢。
###### 7，使用索引
绝大多数情况下，使用索引可以提高查询的速度，但如果SQL语句使用不恰当的话，索引将无法发挥它应有的作用。

下面是应该注意的几个方面。

首先，最好是在相同类型的字段间进行比较的操作。

其次，在建有索引的字段上尽量不要使用函数进行操作。

第三，在搜索字符型字段时，我们有时会使用LIKE关键字和通配符，这种做法虽然简单，但却也是以牺牲系统性能为代价的。

例如下面的查询将会比较表中的每一条记录。

`SELECT * FROM books WHERE name like "MySQL%"`

但是如果换用下面的查询，返回的结果一样，但速度就要快上很多：

`SELECT * FROM books WHERE name＞="MySQL" and name＜"MySQM"`

最后，应该注意避免在查询中让MySQL进行自动类型转换，因为转换过程也会使索引变得不起作用。

###### 8，优化查询语句
