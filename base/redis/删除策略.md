
过期数据在Redis中所有设置了TTL的数据可能不会立即删除，Redis会将该键带上过期时间存放到内存中的一个Expires字典中。
当执行TTL命令后会返回其状态：
```
redis 127.0.0.1:6379> TTL key 

-2: Key已经过期、被删除、未定义
-1: 永久有效 
XX: XX为 key 的剩余生存时间，以秒为单位 
```
这里的已过期数据真的删了吗？
前面说到当存储一个key之后，这个key连同有效期被存储在一个Expires字典中，具体什么时候删除呢？
通常删除某个key，我们有如下三种删除方式：
- 定时删除
- 惰性删除
- 定期删除

#### 1.定时删除
```
创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对key的删除操作。
优点：节省内存，到时就删除，快速释放掉不必要的内存空间
缺点：CPU压力大，无论此时CPU负载有多高，都会占用CPU，影响Redis服务器的响应时间和吞吐量。
总结：用处理器性能换取内存空间（时间换空间）
```
#### 2.惰性删除
```
数据到达过期时间后，不作处理。等待下次访问时，
- 如果未过期，返回数据
- 如果已过期，删除并返回不存在
优点：节约CPU性能，发现必须删除时才删除
缺点：内存压力大，出现长期占用内存空间的数据
总结：用内存空间换取CPU处理性能（空间换时间）
```
#### 3.定期删除
```
定时删除和惰性删除都太极端，定期删除是一个比较好的折中方案。
周期性的轮询Redis库中的时效性数据，采取随机抽取的策略，利用过期数据占比的方式控制删除频度。

特点：
- CPU占用设置有峰值，检测频度可以自己定义
- 内存压力不是很大，长期占用内存的冷数据会被持续清理
总结：周期性抽查存储空间（随机抽查、重点抽查）

定期删除：redis服务器启动初始化时，读取配置的server.hz值，默认为10
每秒执行server.hz次serverCorn()->databaseCron()->activeExpireCycle()
其中activeExpireCycle()对每个Expires[*]逐个检查，每次执行时间为250ms/server.hz
对某个Expires[*]检测室，随机挑选几个key检测：
- 如果key超时，删除key
- 如果一轮中删除key的数量>W*25%，循环该过程(重点抽查)
- 如果一轮中删除key的数量
- 其中W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP的属性值
```
#### 新数据进入检测
```
当新数据进入Redis时，内存不足怎么办？

Redis使用内存存储数据，在执行每一个命令前，都会调用freeMermoryIfNeeded()检测内存是否充足。
如果内存不满足新加入数据的最低存储要求，Redis要临时删除一些数据为当前指令清理存储空间。
清理数据的策略称为：逐出算法（内存淘汰策略）

注意：逐出数据的过程不是100%能够清理出足够的存储空间的，如果不成功会反复执行。当所有数据尝试执行完毕后，如果不能达到内存清理的要求，将出现错误信息。
```
#### 逐出算法配置
```

```







