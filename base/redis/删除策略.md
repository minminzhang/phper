
过期数据在Redis中所有设置了TTL的数据可能不会立即删除，Redis会将该键带上过期时间存放到内存中的一个Expires字典中。
当执行TTL命令后会返回其状态：
```
redis 127.0.0.1:6379> TTL key 

-2: Key已经过期、被删除、未定义
-1: 永久有效 
XX: XX为 key 的剩余生存时间，以秒为单位 
```
这里的已过期数据真的删了吗？
前面说到当存储一个key之后，这个key连同有效期被存储在一个Expires字典中，具体什么时候删除呢？
通常删除某个key，我们有如下三种删除方式：
- 定时删除
- 惰性删除
- 定期删除

#### 1.定时删除
```
创建一个定时器，当key设置有过期时间，且过期时间到达时，由定时器任务立即执行对key的删除操作。
优点：节省内存，到时就删除，快速释放掉不必要的内存空间
缺点：CPU压力大，无论此时CPU负载有多高，都会占用CPU，影响Redis服务器的响应时间和吞吐量。
总结：用处理器性能换取内存空间（时间换空间）
```
#### 2.惰性删除
```
数据到达过期时间后，不作处理。等待下次访问时，
- 如果未过期，返回数据
- 如果已过期，删除并返回不存在
优点：节约CPU性能，发现必须删除时才删除
缺点：内存压力大，出现长期占用内存空间的数据
总结：用内存空间换取CPU处理性能（空间换时间）
```
#### 3.定期删除
```
定时删除和惰性删除都太极端，定期删除是一个比较好的折中方案。
周期性的轮询Redis库中的时效性数据，采取随机抽取的策略，利用过期数据占比的方式控制删除频度。

特点：
- CPU占用设置有峰值，检测频度可以自己定义
- 内存压力不是很大，长期占用内存的冷数据会被持续清理
总结：周期性抽查存储空间（随机抽查、重点抽查）

定期删除：redis服务器启动初始化时，读取配置的server.hz值，默认为10
每秒执行server.hz次serverCorn()->databaseCron()->activeExpireCycle()
其中activeExpireCycle()对每个Expires[*]逐个检查，每次执行时间为250ms/server.hz
对某个Expires[*]检测室，随机挑选几个key检测：
- 如果key超时，删除key
- 如果一轮中删除key的数量>W*25%，循环该过程(重点抽查)
- 如果一轮中删除key的数量
- 其中W取值=ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP的属性值
```
#### 新数据进入检测
```
当新数据进入Redis时，内存不足怎么办？

Redis使用内存存储数据，在执行每一个命令前，都会调用freeMermoryIfNeeded()检测内存是否充足。
如果内存不满足新加入数据的最低存储要求，Redis要临时删除一些数据为当前指令清理存储空间。
清理数据的策略称为：逐出算法（内存淘汰策略）

注意：逐出数据的过程不是100%能够清理出足够的存储空间的，如果不成功会反复执行。当所有数据尝试执行完毕后，如果不能达到内存清理的要求，将出现错误信息。
```
#### Redis删除可以会释放内存吗？

在项目中，Redis的key、value量太多，决定对某个db下的key进行删除，也就是del key
删除前通过 info memory查看内存使用情况
```
Memory
used_memory:2205816296
used_memory_human:4.8G
used_memory_rss:5579214848
used_memory_rss_human:5.70G

通过程序一直删除可丢弃的key，1小时后查看
Memory
used_memory:2205816296
used_memory_human:2.05G
used_memory_rss:5579214848
used_memory_rss_human:5.70G
```
Redis内部的used_memory 已下降至2.05G，但是 used_memory_rss（Redis在系统中进程占用的内存量） 并未降低。

###### 原因
官方给出的具体原因：https://redis.io/topics/memory-optimization

当键被删除时，Redis并不总是释放内存到操作系统中。这并不是Redis的特别之处，大多数malloc()实现都是这样工作的。

例如一个实例有5G的数据,然后删除相当于2G的数据,used_memory_rss可能仍会5G左右。这是因为底层分配器不能轻松地释放内存。
例如，通常将删除的大多数键分配到与其他仍然存在的键相同的页面中。
然而分配器是聪明和能够重用空闲块的内存,所以在你释放2G的5G的数据集,当你开始再次增加键,您将看到used_memory_rss保持稳定而不会再增加很多。
分配器基本上是尝试重用以前(逻辑上)释放的2G内存。
###### 解决方案
我们定义了maxmemory后，并且定义了maxmemory_policy，那么即使内存满了，Redis也会按照淘汰机制方案，清除一些不需要的key，来存放新的key。

但是如果已经影响到系统内存使用了，也有下面三种方案：
1，可以通过 MEMORY PURGE命令进行内存整理。（瞬时，能稍微腾出rss内存空间）
2，开启activedefrag，热碎片整理。（会占用CPU，在主线程执行，可以设置CPU占用率）
3，重启。













